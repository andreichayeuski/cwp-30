#CWP/TASK/30 - SSO и двухфакторная аутентификация
function task00() {

Создаем на Github репозиторий cwp-30, клонируем его, открываем в IDE

Устанавливаем sequelize, express, cookie-parser, jsonwebtoken и bcryptjs

Будем реализовывать стратегию аутентификации Single Sign-On с двумя факторами

}

function task01() {

Потребуется одна таблица и sequelize-модель к ней

User:

"id": int / autoincrement

"email": string

"password": string

"codes": string / json array

Создадим эту таблицу в code first стиле и предзаполним тестовыми данными (тоже из кода, как в примере из лекции 17). Учтём, что пароли будут хранится в хэшированном виде с помощью пакета bcrypt

В поле codes поместим 4 случайных 5-ти значных числа в виде массива. Например, [12345,54321,44444,21543]

}

function task02() {

В файлах sso.js и service.js реализуем express-сервера использующие стратегию SSO

Финальный алгоритм работы будет выглядтеть следующим образом:

1. Пользователь запрашивает у сервиса (service.js) ресурс /protected-resource

2. Сервис проверяет cookie __service_token и проверяет валидность токена

2а. Верно: загружает пользователя из БД, отдаёт в формате JSON

2б. Неверно: перенаправляет на аутентификатор (sso.js) с указанием адреса исходного запроса (source) и адреса колбека для сохранения токена (callback) в query

- localhost:8000/login?source=/protected-resource&callback=localhost:7000/token

3. Аутентификатор проверяет cookie __sso_token и проверяет валидность токена

3а. Верно: => (9)

3б. Неверно: отдаёт форму для логина

4. Пользователь заполняет форму и отправляет обратно аутентификатору

5. Аутентификатор находит пользователя в БД, сравнивает верность пароля

5а. Верно: генерирует jwt-токен с id пользователя в качестве полезной нагрузки с временем жизни 1 минута, генерирует цифру от 1 до 4

5б. Неверно: отдаёт ошибку

6. Перенаправляет пользователя на форму ввода кода

- localhost:8000/codes?source=X&callback=Y&token=Z&code=2

7. Пользователь вводит код под соответстующим номером (в нашем примере второй код) и отправляет обратно аутентификатору

8. Аутентификатор проверяет валидность токена и правильность кода 8а. Верно: генерирует jwt-токен с id пользователя в качестве полезной нагрузки с временем жизни 30 минут, записывает токен в cookie __sso_token

8б. Неверно: отдаёт ошибку

9. Перенаправляет пользователя на callback с указанием с указанием адреса исходного запроса (source) и токена (token) в query

- http://localhost:7000/token?source=/protected-resource&token=XYZ

10. Сервис сохраняет токен в cookie __service_token и перенаправляет пользователя на адреса исходного запроса (source)

11. => (2)

}